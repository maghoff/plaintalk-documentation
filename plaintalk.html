<!DOCTYPE HTML>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">

<!--
<link href='https://fonts.googleapis.com/css?family=Cherry+Swash' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Fenix' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>
-->
<link href='plaintalk.css' rel='stylesheet' type='text/css'>

<!--
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
-->
<script src="d3.v3.min.js" charset="utf-8"></script>

</head>
<body>

<div class="banner">
<div class="content">
PlainTalk
</div>
</div>

<div class="content">
<p>
PlainTalk is a <span class="has-definition" title="In other words: a protocol that splits
a stream into discrete messages, each message composed of any number of fields.">
message and field framing protocol</span> that is human readable and writable while still
efficiently processable by computers. PlainTalk was designed by <a href="...">Rolf Wilhelm
Rasmussen</a> for use in real time graphics systems for broadcast TV.
</p>

<p>
When designing a network protocol, PlainTalk is a useful starting point. It fits in the
network stack right underneath the application layer and offers a message based API to
the layer above it.
</p>

<h1>What does it look like?</h1>
<pre class="plaintalk">
<span class="message to-server"><span class="field">0</span> <span class="field">protocol</span> <span class="field">doubletalk</span></span>
<span class="message from-server"><span class="field">0</span> <span class="field">protocol</span> <span class="field">doubletalk</span></span>
<span class="message to-server"><span class="field">1</span> <span class="field">define</span> <span class="field">ignorance</span></span>
<span class="message from-server"><span class="field">1</span> <span class="field">ok</span> <span class="field"><span class="control">{21}</span>ignorance is strength</span></span>
</pre>

<p>
This is an example of what a network session using a PlainTalk-based protocol might look
like. Each message is separated by a newline, each field is separated by a space.
</p>

<p>
In the second message from the server, <code class="plaintalk field">
ignorance is strength</code> is one field with embedded space characters. It is
possible to transmit control characters by using the sequence <code class=
"plaintalk"><span class="control">{<span class="annotation">n</span>}</span></code>,
followed by <span class="annotation">n</span> bytes to be read
verbatim, without interpretation. An escape sequence can appear anywhere within
a field, so the byte sequence <code class="plaintalk"><span class=
"control">{21}</span>ignorance is strength</code> is exactly equivalent to both
<code class="plaintalk">ignorance<span class="control">{1}</span> is<span class="control">{1}</span> strength</code>
and <code class="plaintalk">ignoranc<span class="control">{7}</span>e is strength</code>.
This makes it easy to implement streaming of arbitrary binary data.
</p>

<h1>That's it?</h1>

<p>
Basically, that's it. Newlines between messages, spaces between fields, plus an
escaping mechanism. But let us go through all the details as well.
</p>

<svg width="800" height="300">
<defs>
	<marker id="arrow-end-lol" style="overflow:visible;" orient="auto">
	<path
		d="M 8.7185878,4.0337352 L -2.2072895,0.016013256 L 8.7185884,-4.0017078 C 6.9730900,-1.6296469 6.9831476,1.6157441 8.7185878,4.0337352 z "
		style="fill-rule:evenodd;stroke-width:0.62500000;stroke-linejoin:round;"
		transform="scale(2) rotate(180) translate(1,0)"
	/>
	</marker>
	<marker id="arrow-end" style="overflow:visible;" orient="auto">
	<path
		d="M -20 0 l -15 7 M -20 0 l -15 -7"
		style="stroke:black; fill:none; stroke-linejoin:round;"
	/>
	</marker>
</defs>
<path class="transition" d="M 100 100 a 300,300 0 0 1 300,0"/>
<path class="transition" d="M 50 100 l 50 0"/>
<circle class="state" cx="100" cy="100" r="20"/>
<circle class="state" cx="400" cy="100" r="20"/>
<circle class="state" cx="480" cy="250" r="20"/>
<circle class="state" cx="320" cy="250" r="20"/>
</svg>

<p>
Basically, that's it. Newlines between messages, spaces between fields, plus an
escaping mechanism. But let us go through all the details as well.
</p>

<div class="draft">
<h1>Async</h1>

<p>
The queries from the client have been shown interleaved with the responses from the server.
However, each message is tagged with an identifier, which lets us use the protocol
asynchronously, like this:
</p>

<pre class="plaintalk">
<span class="message to-server"><span class="field">2</span> <span class="field">define</span> <span class="field">war</span></span>
<span class="message to-server"><span class="field">3</span> <span class="field">define</span> <span class="field">freedom</span></span>
<span class="message from-server"><span class="field">3</span> <span class="field">ok</span> <span class="field">freedom<span class="control">{1}</span> is<span class="control">{1}</span> slavery</span></span>
<span class="message from-server"><span class="field">2</span> <span class="field">ok</span> <span class="field">war<span class="control">{1}</span> is<span class="control">{1}</span> peace</span></span>
</pre>

<p>
Support for asynchronous handling of messages is not a part of PlainTalk, but it is
recommended that protocols built on top of PlainTalk implement support for it this
way.
</p>
</div>

</div>

<div class="footer"><div class="content">&mdash; Magnus Hoff, 2013</div></div>

</body>
</html>
